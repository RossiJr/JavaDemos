package org.rossijr.basiccrud.service;

import org.rossijr.basiccrud.dto.TaskCreateRequestDTO;
import org.rossijr.basiccrud.dto.TaskGetResponseDTO;
import org.rossijr.basiccrud.dto.TaskUpdateRequestDTO;
import org.rossijr.basiccrud.enums.Status;
import org.rossijr.basiccrud.model.Project;
import org.rossijr.basiccrud.model.Task;
import org.rossijr.basiccrud.repository.TaskRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.ZonedDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * <ul>
 * <li>Service class for managing {@link Task} entities.</li>
 * </li>In this layer, usually the business logic is implemented.</li>
 *
 * <ul>
 * <li>{@code @Service}: Indicates that this class is a Spring service (holds the business logic).</li>
 * </ul>
 * </ul>
 */
@Service
public class TaskService {
    private final TaskRepository taskRepository;
    private final ProjectService projectService;

    @Autowired
    public TaskService(TaskRepository taskRepository, ProjectService projectService) {
        this.taskRepository = taskRepository;
        this.projectService = projectService;
    }

    /**
     * Retrieves all tasks from the database and converts them to a list of TaskGetResponseDTO objects.
     *
     * @return a list of TaskGetResponseDTO objects.
     */
    public List<TaskGetResponseDTO> getAllTasks() {
        // Get all the tasks from the database
        List<Task> tasks = taskRepository.findAll();

        // Convert the list of Task entities to a list of TaskGetResponseDTO objects (Can be done using ModelMapper, but let's keep it simple)
        // The use of the DTO pattern helps to separate the internal representation of the data from the external representation (API response, for example),
        // providing more flexibility and control over the data being exposed (avoid exposing sensitive information, for example).
        //
        // The use of the Stream API here is just a more concise way to iterate over the list and map each Task entity to a TaskGetResponseDTO object.
        // Let's see how it is done:
        // 1. tasks.stream(): Converts the list of tasks into a Stream<Task>.
        // 2. map(task -> ...): Maps each Task object to a TaskGetResponseDTO object.
        // 2.1. new TaskGetResponseDTO(...): Creates a new TaskGetResponseDTO object with the data from the Task entity, using a previous declared constructor
        // 3. collect(Collectors.toList()): Collects the Stream<TaskGetResponseDTO> into a List<TaskGetResponseDTO> (basically transforms the stream into a List)
        return tasks.stream()
                .map(task -> new TaskGetResponseDTO(
                        task.getId(),
                        task.getTitle(),
                        task.getDescription(),
                        task.getCreatedAt(),
                        task.getUpdatedAt(),
                        task.getDueDate(),
                        task.getPriority().name(),
                        task.getStatus().name()
                ))
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a task by its ID from the database and converts it to a TaskGetResponseDTO object.
     *
     * @param id the ID of the task to be retrieved.
     * @return a TaskGetResponseDTO object.
     */
    public TaskGetResponseDTO getTaskById(Long id) {
        // Check if the ID is null or invalid
        if (id == null || id <= 0) {
            return null;
        }

        // Find the task by its ID in the database (if it exists, if not return null)
        Task task = taskRepository.findById(id).orElse(null);

        // Convert the Task entity to a TaskGetResponseDTO object (if the task exists, if not return null)
        return task != null ? new TaskGetResponseDTO(
                task.getId(),
                task.getTitle(),
                task.getDescription(),
                task.getCreatedAt(),
                task.getUpdatedAt(),
                task.getDueDate(),
                task.getPriority().name(),
                task.getStatus().name()
        ) : null;
    }

    /**
     * Creates a new task in the database and returns it (important to return the created object
     * because it may contain fields that were generated by the database, like the ID).
     *
     * @param task a TaskCreateRequestDTO object containing the details of the task to be created.
     * @return a TaskGetResponseDTO object.
     */
    public TaskGetResponseDTO createTask(TaskCreateRequestDTO task) {
        // Check if the task is null
        if (task == null) {
            return null;
        }

        // Create a new Task entity with the data from the TaskCreateUpdateRequestDTO object
        Task newTask = new Task();
        newTask.setTitle(task.getTitle());
        newTask.setDescription(task.getDescription());
        newTask.setDueDate(task.getDueDate());
        newTask.setProject(new Project(task.getProjectId()));
        newTask.setPriority(task.getPriority());

        // Set default fields
        newTask.setCreatedAt(ZonedDateTime.now());
        newTask.setUpdatedAt(ZonedDateTime.now());
        newTask.setStatus(Status.TO_DO);

        // Save the new task in the database
        newTask = taskRepository.save(newTask);

        // Convert the Task entity to a TaskGetResponseDTO object
        return new TaskGetResponseDTO(
                newTask.getId(),
                newTask.getTitle(),
                newTask.getDescription(),
                newTask.getCreatedAt(),
                newTask.getUpdatedAt(),
                newTask.getDueDate(),
                newTask.getPriority().name(),
                newTask.getStatus().name()
        );
    }


    /**
     * Updates a task in the database and returns it (important to return the updated object because it may contain fields that were updated).
     *
     * @param task a TaskUpdateRequestDTO object containing the details of the task to be updated.
     * @return a TaskGetResponseDTO object.
     */
    public TaskGetResponseDTO updateTask(TaskUpdateRequestDTO task) {
        // Check if the task is null
        if (task == null) {
            return null;
        }


        // Important to note, it's important to create a new Task entity with the data from the TaskCreateUpdateRequestDTO object,
        // so only selected fields are updated, and the others (that the business logic does not allow to update) remain the same.
        // Find the task by its ID in the database (if it exists, if not return null)
        Task taskToUpdate = taskRepository.findById(task.getId()).orElse(null);
        if (taskToUpdate == null) {
            return null;
        }

        // It's important to check if the fields are null before updating them, otherwise, they will be overwritten with null values
        taskToUpdate.setTitle(task.getTitle() != null ? task.getTitle() : taskToUpdate.getTitle());
        taskToUpdate.setDescription(task.getDescription() != null ? task.getDescription() : taskToUpdate.getDescription());
        taskToUpdate.setDueDate(task.getDueDate() != null ? task.getDueDate() : taskToUpdate.getDueDate());

        // It's also important to check if the project exists, otherwise, it will make invalid relationships in the database
        if (projectService.isValidProjectId(task.getProjectId())) {
            taskToUpdate.setProject(new Project(task.getProjectId()));
        }

        taskToUpdate.setPriority(task.getPriority() != null ? task.getPriority() : taskToUpdate.getPriority());
        taskToUpdate.setStatus(task.getStatus() != null ? task.getStatus() : taskToUpdate.getStatus());

        // Update the field that marks the last update
        taskToUpdate.setUpdatedAt(ZonedDateTime.now());

        // Save the updated task in the database
        taskToUpdate = taskRepository.save(taskToUpdate);

        // Convert the Task entity to a TaskGetResponseDTO object
        return new TaskGetResponseDTO(
                taskToUpdate.getId(),
                taskToUpdate.getTitle(),
                taskToUpdate.getDescription(),
                taskToUpdate.getCreatedAt(),
                taskToUpdate.getUpdatedAt(),
                taskToUpdate.getDueDate(),
                taskToUpdate.getPriority().name(),
                taskToUpdate.getStatus().name()
        );
    }


    /**
     * Deletes a task by its ID from the database.
     *
     * @param id the ID of the task to be deleted.
     */
    public void deleteTask(Long id) {
        // Check if the ID is null
        if (id == null) {
            throw new IllegalArgumentException("ID cannot be null");
        }

        // Find the task by its ID in the database (if it exists, if not return null)
        Task task = taskRepository.findById(id).orElse(null);

        // Check if the task exists
        if (task == null) {
            throw new IllegalArgumentException("Task not found");
        }

        // Delete the task from the database
        taskRepository.delete(task);
    }
}
